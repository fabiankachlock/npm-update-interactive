{"version":3,"file":"cli.js","sources":["../src/npmjs.ts","../src/package.ts","../src/bin/cli.ts"],"sourcesContent":["import { execSync } from 'child_process'\nimport semver from 'semver'\n\nexport const getAvailableVersions = (packageName: string, packageManager: string): string[] => {\n  const action = packageManager === 'yarn' ? 'info' : 'view'\n  const command = `${packageManager} ${action} ${packageName} versions --json`\n\n  const result = execSync(command, {\n    encoding: 'utf-8',\n  })\n  // strip everything before [ and after ]\n  const version = JSON.parse(result)\n  return semver.rsort(version)\n}\n","import { readFileSync, existsSync } from 'node:fs'\nimport { join, normalize, dirname } from 'node:path'\n\nexport type Dependency = {\n  name: string\n  version: string\n  installedVersion?: string\n}\n\nexport type DependenciesResult = {\n  dependencies: Dependency[]\n  packageJsonPath: string\n  packageManager: string\n}\n\nconst findProjectPackageJson = (path?: string): string | undefined => {\n  let currentPath = path ?? join(process.cwd(), 'package.json')\n  while (currentPath) {\n    if (existsSync(currentPath)) {\n      return currentPath\n    }\n    const newPath = normalize(join(dirname(currentPath), '..'))\n    if (newPath === path) {\n      // reached the root directory\n      return undefined\n    }\n    path = newPath\n  }\n}\n\nconst findDependencyPackageJson = (packageJsonPath: string, dependencyName: string): string | undefined => {\n  const projectRoot = join(dirname(packageJsonPath), 'node_modules')\n  const requirePath = require.resolve.paths(dependencyName) ?? []\n  const allPaths = [...requirePath, projectRoot]\n\n  for (const basePath of allPaths) {\n    const packageJsonPath = join(basePath, dependencyName, 'package.json')\n    if (existsSync(packageJsonPath)) {\n      return packageJsonPath\n    }\n  }\n  return undefined\n}\n\nconst findePackageManager = (packageJsonPath: string): string => {\n  try {\n    const packageJson = readFileSync(packageJsonPath, 'utf-8')\n    const { packageManager } = JSON.parse(packageJson)\n    if (packageManager) {\n      const [name] = packageManager.split('@')\n      return name\n    }\n    const projectRoot = dirname(packageJsonPath)\n    if (existsSync(join(projectRoot, 'pnpm-lock.yaml'))) {\n      return 'pnpm'\n    } else if (existsSync(join(projectRoot, 'yarn.lock'))) {\n      return 'yarn'\n    } else if (existsSync(join(projectRoot, 'package-lock.json'))) {\n      return 'npm'\n    }\n  } catch {}\n  return 'npm'\n}\n\nexport const getDependencies = (path?: string): DependenciesResult | undefined => {\n  const packageJsonPath = findProjectPackageJson(path)\n  if (!packageJsonPath) {\n    return undefined\n  }\n  const packageJson = readFileSync(packageJsonPath, 'utf-8')\n\n  const { dependencies = {}, devDependencies = {} } = JSON.parse(packageJson)\n  const dependenciesAndVersions = Object.entries(dependencies)\n    .concat(Object.entries(devDependencies))\n    .map(([name, version]) => {\n      try {\n        const dependencyPackageJsonPath = findDependencyPackageJson(packageJsonPath, name)\n        const dependencyPackageJson = dependencyPackageJsonPath && readFileSync(dependencyPackageJsonPath, 'utf-8')\n        return {\n          name,\n          version: version as string,\n          installedVersion: JSON.parse(dependencyPackageJson ?? '').version,\n        }\n      } catch {\n        return {\n          name,\n          version: version as string,\n        }\n      }\n    })\n\n  return {\n    dependencies: dependenciesAndVersions,\n    packageJsonPath,\n    packageManager: findePackageManager(packageJsonPath),\n  }\n}\n","import { getAvailableVersions } from '../npmjs'\nimport { getDependencies } from '../package'\nimport promps from 'prompts-ncu'\n;(async () => {\n  console.log('## npm-update-interactive ##')\n  const { dependencies, packageJsonPath, packageManager } = getDependencies()!\n  const updates = {} as Record<string, string>\n\n  while (true) {\n    const { value } = await promps({\n      type: 'autocomplete',\n      name: 'value',\n      message: 'Select a package to update',\n      choices: dependencies\n        .map(dependency => ({\n          title: `${dependency.name}@${dependency.version} (${dependency.installedVersion})`,\n          value: dependency.name,\n        }))\n        .concat({\n          title: 'Exit',\n          value: 'exit',\n        }),\n    })\n\n    if (value === 'exit') break\n\n    if (!value) return\n    const availableVersions = getAvailableVersions(value, packageManager)\n    const { version } = await promps({\n      type: 'autocomplete',\n      name: 'version',\n      message: `Select a version to update ${value}`,\n      choices: availableVersions.map(version => ({\n        title: version,\n        value: version,\n      })),\n    })\n    if (!version) return\n    updates[value] = version\n  }\n\n  console.log('## Updates ##')\n  console.log(updates)\n})()\n"],"names":["getAvailableVersions","packageName","packageManager","command","result","execSync","version","semver","findProjectPackageJson","path","currentPath","join","existsSync","newPath","normalize","dirname","findDependencyPackageJson","packageJsonPath","dependencyName","projectRoot","allPaths","basePath","findePackageManager","packageJson","readFileSync","name","getDependencies","dependencies","devDependencies","dependencyPackageJsonPath","dependencyPackageJson","updates","value","promps","dependency","availableVersions"],"mappings":"4IAGaA,EAAuB,CAACC,EAAqBC,IAAqC,CAE7F,MAAMC,EAAU,GAAGD,CAAc,IADlBA,IAAmB,OAAS,OAAS,MACT,IAAID,CAAW,mBAEpDG,EAASC,WAASF,EAAS,CAC/B,SAAU,OAAA,CACX,EAEKG,EAAU,KAAK,MAAMF,CAAM,EAC1B,OAAAG,EAAO,MAAMD,CAAO,CAC7B,ECEME,EAA0BC,GAAsC,CACpE,IAAIC,EAAcD,GAAQE,EAAAA,KAAK,QAAQ,MAAO,cAAc,EAC5D,KAAOD,GAAa,CACd,GAAAE,EAAAA,WAAWF,CAAW,EACjB,OAAAA,EAET,MAAMG,EAAUC,EAAAA,UAAUH,EAAA,KAAKI,UAAQL,CAAW,EAAG,IAAI,CAAC,EAC1D,GAAIG,IAAYJ,EAEP,OAEFA,EAAAI,CAAA,CAEX,EAEMG,EAA4B,CAACC,EAAyBC,IAA+C,CACzG,MAAMC,EAAcR,EAAA,KAAKI,EAAQ,QAAAE,CAAe,EAAG,cAAc,EAE3DG,EAAW,CAAC,GADE,QAAQ,QAAQ,MAAMF,CAAc,GAAK,CAAC,EAC5BC,CAAW,EAE7C,UAAWE,KAAYD,EAAU,CAC/B,MAAMH,EAAkBN,EAAA,KAAKU,EAAUH,EAAgB,cAAc,EACjE,GAAAN,EAAAA,WAAWK,CAAe,EACrBA,OAAAA,CACT,CAGJ,EAEMK,EAAuBL,GAAoC,CAC3D,GAAA,CACI,MAAAM,EAAcC,EAAAA,aAAaP,EAAiB,OAAO,EACnD,CAAE,eAAAf,CAAmB,EAAA,KAAK,MAAMqB,CAAW,EACjD,GAAIrB,EAAgB,CAClB,KAAM,CAACuB,CAAI,EAAIvB,EAAe,MAAM,GAAG,EAChC,OAAAuB,CAAA,CAEH,MAAAN,EAAcJ,UAAQE,CAAe,EAC3C,GAAIL,EAAW,WAAAD,EAAA,KAAKQ,EAAa,gBAAgB,CAAC,EACzC,MAAA,UACEP,EAAAA,WAAWD,EAAAA,KAAKQ,EAAa,WAAW,CAAC,EAC3C,MAAA,UACEP,EAAAA,WAAWD,EAAAA,KAAKQ,EAAa,mBAAmB,CAAC,EACnD,MAAA,KACT,MACM,CAAA,CACD,MAAA,KACT,EAEaO,EAAmBjB,GAAkD,CAC1E,MAAAQ,EAAkBT,EAAuBC,CAAI,EACnD,GAAI,CAACQ,EACI,OAEH,MAAAM,EAAcC,EAAAA,aAAaP,EAAiB,OAAO,EAEnD,CAAE,aAAAU,EAAe,CAAA,EAAI,gBAAAC,EAAkB,CAAG,CAAA,EAAI,KAAK,MAAML,CAAW,EAoBnE,MAAA,CACL,aApB8B,OAAO,QAAQI,CAAY,EACxD,OAAO,OAAO,QAAQC,CAAe,CAAC,EACtC,IAAI,CAAC,CAACH,EAAMnB,CAAO,IAAM,CACpB,GAAA,CACI,MAAAuB,EAA4Bb,EAA0BC,EAAiBQ,CAAI,EAC3EK,EAAwBD,GAA6BL,eAAaK,EAA2B,OAAO,EACnG,MAAA,CACL,KAAAJ,EACA,QAAAnB,EACA,iBAAkB,KAAK,MAAMwB,GAAyB,EAAE,EAAE,OAC5D,CAAA,MACM,CACC,MAAA,CACL,KAAAL,EACA,QAAAnB,CACF,CAAA,CACF,CACD,EAID,gBAAAW,EACA,eAAgBK,EAAoBL,CAAe,CACrD,CACF,GC7FE,SAAY,CACZ,QAAQ,IAAI,8BAA8B,EAC1C,KAAM,CAAE,aAAAU,EAAc,gBAAAV,EAAiB,eAAAf,CAAA,EAAmBwB,EAAgB,EACpEK,EAAU,CAAC,EAEjB,OAAa,CACX,KAAM,CAAE,MAAAC,GAAU,MAAMC,EAAO,CAC7B,KAAM,eACN,KAAM,QACN,QAAS,6BACT,QAASN,EACN,IAAmBO,IAAA,CAClB,MAAO,GAAGA,EAAW,IAAI,IAAIA,EAAW,OAAO,KAAKA,EAAW,gBAAgB,IAC/E,MAAOA,EAAW,IAAA,EAClB,EACD,OAAO,CACN,MAAO,OACP,MAAO,MACR,CAAA,CAAA,CACJ,EAED,GAAIF,IAAU,OAAQ,MAEtB,GAAI,CAACA,EAAO,OACN,MAAAG,EAAoBnC,EAAqBgC,EAAO9B,CAAc,EAC9D,CAAE,QAAAI,GAAY,MAAM2B,EAAO,CAC/B,KAAM,eACN,KAAM,UACN,QAAS,8BAA8BD,CAAK,GAC5C,QAASG,EAAkB,IAAI7B,IAAY,CACzC,MAAOA,EACP,MAAOA,CAAA,EACP,CAAA,CACH,EACD,GAAI,CAACA,EAAS,OACdyB,EAAQC,CAAK,EAAI1B,CAAA,CAGnB,QAAQ,IAAI,eAAe,EAC3B,QAAQ,IAAIyB,CAAO,CACrB,GAAG"}