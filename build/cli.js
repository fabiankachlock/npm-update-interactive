"use strict";const m=require("commander"),g=require("node:fs"),k=require("node:fs/promises"),a=require("node:path"),f=require("prompts-ncu"),h=require("node:child_process"),w=require("semver"),y=n=>{let e=n??a.join(process.cwd(),"package.json");for(;e;){if(g.existsSync(e))return e;const t=a.normalize(a.join(a.dirname(e),".."));if(t===e)return;e=t}},j=(n,e)=>{const t=a.join(a.dirname(n),"node_modules"),o=a.join(process.cwd(),"node_modules"),c=[...require.resolve.paths(e)??[],t,o];for(const p of c){const s=a.join(p,e,"package.json");if(g.existsSync(s))return s}},P=async n=>{try{const e=await k.readFile(n,"utf-8"),{packageManager:t}=JSON.parse(e);if(t){const[i]=t.split("@");return i}const o=a.dirname(n);if(g.existsSync(a.join(o,"pnpm-lock.yaml")))return"pnpm";if(g.existsSync(a.join(o,"yarn.lock")))return"yarn";if(g.existsSync(a.join(o,"package-lock.json")))return"npm"}catch{}return"npm"},S=async n=>{const e=await k.readFile(n,"utf-8"),{dependencies:t={},devDependencies:o={}}=JSON.parse(e),i=Object.entries(t).concat(Object.entries(o)).map(([c,p])=>{try{const s=j(n,c);return s?new Promise(async(r,d)=>{const l=await k.readFile(s,"utf-8");r({name:c,version:p,installedVersion:JSON.parse(l??"").version})}):void 0}catch{return{name:c,version:p}}});return Promise.all(i.filter(Boolean))},x=async n=>{const{packages:e}=await f({type:"autocompleteMultiselect",name:"packages",message:"Select packages to update",choices:n.map(t=>({title:`${t.name}@${t.version} (${t.installedVersion})`,value:t.name}))});return e},$=async(n,e)=>{const{version:t}=await f({type:"autocomplete",name:"version",hint:"Select skip to skip updating this package.",message:`Select a new version for '${n}'`,choices:e.map(o=>({title:o,value:o})).concat({title:"Skip",value:"##skip"})});if(t!=="##skip")return t},b=async n=>{const{nextStep:e}=await f({type:"select",name:"nextStep",message:"What do you want to do next?",choices:[{title:"Update packages",value:"update"},{title:"Select more packages",value:"select"},{title:"Abort",value:"abort"}]});return e},q=(n,e)=>{const o=`${e} ${e==="yarn"?"info":"view"} ${n} versions --json`,{promise:i,resolve:c,reject:p}=Promise.withResolvers();return h.exec(o,{encoding:"utf-8"},(s,r,d)=>{s&&p(s);const l=JSON.parse(r),u=w.rsort(l);c(u)}),i};(async()=>{console.log("## npm-update-interactive ##"),m.program.name("npm-update-interactive").description("Update npm packages interactively").version("1.0.0").option("-c, --config <path>","Path to the package json file",void 0).option("-p, --package-manager <name>","Package manager to use",void 0),m.program.parse(process.argv);const{config:n,packageManager:e}=m.program.opts(),t=y(n);t||(console.error("No package.json found"),process.exit(1)),console.log(`Using package.json: ${t}`);const o=e||await P(t);console.log(`Using package manager: ${o}`);const i=await S(t),c={};for(;;){const p=await x(i);for(const r of p){const d=i.find(v=>v.name===r),l=await q(r,o),u=await $(r,l);u&&(c[r]={dependency:d,newVersion:u})}console.log("Selected packages to update:");for(const[r,{dependency:d,newVersion:l}]of Object.entries(c))console.log(`- ${r}: ${d.version} -> ${l}`);const s=await b();if(s==="abort"&&(console.log("Aborting..."),process.exit(0)),s==="update")break}console.log("Updating packages...")})();
//# sourceMappingURL=cli.js.map
